I'll run you through creating a simple project with Scaffold. I'm going to assumed that you are using the same setup as the example files. Your structure should look something like this:

<pre><code>
	/scaffold
	/css
		/.htaccess
		/screen.css
	/index.html
</code></pre>

See the setup instructions ([[Installation]]) if you're having trouble. For this tutorial, I'm going to assume your screen.css is blank also - we're going to start from scratch.

h2. Load your css file

Navigate to screen.css in your browser by going through Scaffold.

@http://localhost/scaffold/index.php?request=css/screen.css&recache@

You should see the compressed css file. I'll explain how this works. To get Scaffold to work, we're actually pointing to a php file which loads the css, processes it, and then outputs it as css to the browser. This will work in exactly the same way as a browser calling the css file directly. We tell Scaffold the file we want to process using the 'request' url parameter. This is an absolute url to your css file. 

You'll notice the 'recache' parameter in there also. By default, Scaffold tries to detect if you have made any changes to the requested file since the last time it cached it. If there isn't, it will just point to the cache, otherwise, it will load the css, process it and cache it again. We can force a recache by using the url parameter. 

If you've setup the .htaccess file as well, (there's an example in the css folder), you can open your css files normally and they will be parsed by Scaffold:

@http://localhost/css/screen.css?recache@

This will produce the same results as the above method if you have the .htaccess setup. This allows you to use Scaffold completely transparently, so it can do its job in the background without you even noticing.

h2. Constants

Open your blank screen.css file. The first thing I'm going to show you are constants. You declare your constants in a very css-style.

<pre><code>
	@constants
	{
		text_color:#555;
		color_1:#999;
	}
</code></pre>

We've defined 2 constants - 'text_color' and 'color_1'. To use those constants, we do this:

<pre><code>
	body
	{
		color:!text_color;
	}
</code></pre>

That's it. It will output the value you defined earlier. It doesn't matter where you define your constants, they could be at the very end of your css file. You can also use any value you want in there - text, numbers, units, selectors etc.

So now, screen.css should look like this:

<pre><code>
	@constants
	{
		text_color:#555;
		color_1:#999;
	}

	body
	{
		color:!text_color;
	}
</code></pre>

At this point, it should also be noted that @colors is *exactly* the same as @constants. It just provides a more meaningful and organised way to define your colors. 

h2. Imports

One of the great things about Scaffold is that it minimises HTTP requests by the browser. Scaffold overrides the default @import declaration, and imports the files server-side before its cached and sent to the browser. This means you only send 1 file, not 4 or 5. 

Scaffold comes with some snippets for you to use. These are stored in @/scaffold/snippets@. Let's import the reset file. Add this line to the top of your css:

<pre><code>
	@import '/scaffold/snippets/reset.css';
</code></pre>

Now open the css in your browser again. You should see all of the reset styles prepended to the file.

h2. Conditionals

Now that you know how to import files, I'll show you how to leverage Scaffolds browser detection to load files for particular browsers. 

<pre><code>
	@if(!browser = "Internet Explorer")
	{
		@import '/scaffold/snippets/ie-fixes.css';
	}
</code></pre>

This will only import the css file for IE. @!browser@ is a built-in constant that outputs the browser. There is also @!version@:

<pre><code>
	@if(!browser == "Internet Explorer" && !version == 6)
	{
		@import '/scaffold/snippets/ie-fixes.css';
		body {display:none}
	}
</code></pre>

It's much easier being able to do this inside your css. You can also target Firefox, Safari and Opera. Be very careful with browser-specific css, and only use it when absolutely necessary. You really should only need it for IE, and perhaps fixing a pixel or 2 difference in Firefox or Safari. Never rely on it for a vast chunk of your styles.

You css file should look like this now:

<pre><code>
	@import '/scaffold/snippets/reset.css';
	
	@if(!browser == "Internet Explorer")
	{
		@import '/scaffold/snippets/ie-fixes.css';
		body {display:none}
	}
	
	@constants
	{
		text_color:#555;
		color_1:#999;
	}

	body
	{
		color:!text_color;
	}
</code></pre>

h2. Grid

The grid module is by far the most useful of them all. @@grid@ allows you to do define your grid inside your css, and have access it classes, properties, constants and mixins all based on your grid. It creates all of the 'standard' grid classes - .columns-x, .span-x, .push-x etc - and will add them to your css at the end for using on the front-end. For the back-end however, you can use a few different methods depending on your tastes. For example:

<pre><code>
	#content
	{
		columns:10;
	}
</code></pre>

This will make the element behave like a column or grid unit. It outputs these values:

<pre><code>
	#content
	{
		width:x;
		float:left;
		margin-left:x;
		margin-right:x;
	}
</code></pre>

Depending on whether the browser supports it, it also adds @box-sizing@ and fixes IE bugs with @display:inline@ and @overflow:hidden@. The important part about this property is that it will factor in extra width *on that selector.* For example:

<pre><code>
	#content
	{
		columns:10;
		padding:10px;
		border:1px solid #eee;
	}
</code></pre>

This won't break your layout. You don't need to adjust any widths for this to work. @@grid@ gives you access to mixins and a generated grid image as well, but I'll explain these later. 

h2. Mixins

Mixins are like functions for css. They let you define properties and add them as a group to a selector. They can have parameters and they can be nested within each other. The idea was ported over from SASS.

This is the syntax of a basic mixin: 

<pre><code>
	=mixin-name(!param, !param2 = 0)
	{
		color:!param;
		border: !param2 solid #eee;
	}
</code></pre>

Then you assign this to a selector

<pre><code>
	#content
	{
		+mixin-name(#eee);
		
		columns:10;
		padding:10px;
		border:1px solid #eee;
	}
</code></pre>

The parameters are optional, you can leave them off entirely if you don't need them. The benefit of this is that you can have much more useful snippets of css you can use, in a similar way to classes, but without the need for creating other classes to "extend" or modify them. 

More to come...


